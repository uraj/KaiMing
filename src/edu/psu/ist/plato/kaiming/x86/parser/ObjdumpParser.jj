PARSER_BEGIN(ObjdumpParser)package edu.psu.ist.plato.kaiming.x86.parser;import edu.psu.ist.plato.kaiming.x86.AsmLabel;import edu.psu.ist.plato.kaiming.x86.Function;import edu.psu.ist.plato.kaiming.x86.Opcode;import edu.psu.ist.plato.kaiming.x86.Instruction;import edu.psu.ist.plato.kaiming.x86.Operand;import edu.psu.ist.plato.kaiming.x86.Register;import edu.psu.ist.plato.kaiming.x86.Immediate;import edu.psu.ist.plato.kaiming.x86.Memory;import edu.psu.ist.plato.kaiming.util.Tuple;import java.util.ArrayList;import java.util.List;public class ObjdumpParser {}PARSER_END(ObjdumpParser)SKIP: { " " | "\r" | "\t" }TOKEN: { "(" | ")" | ","	| <NL: ("\n")+>	| <LABEL: ["a"-"z","A"-"Z","_"](["_","-","@",".","a"-"z","A"-"Z","0"-"9"])*":">	| <INT: ("-")?(("0x"(["0"-"9","a"-"f"])+)|(["0"-"9"])+)>	| <IMM: "$"("0x")?(["0"-"9", "a"-"f"])+>	| <MEM: "0x"(["0"-"9","a"-"f"])+>	| <OPCODE: (["a"-"z"])+(["a"-"z","0"-"9"])*|(("rep"|"repz"|"repe"|"repnz"|"repne"|"lock")" ")(["a"-"z"])+(["a"-"z","0"-"9"])*>	| <SREG: "%"("fs"|"gs"|"cs"|"ds"|"ss"|"es")>	| <REG: "%"(["a"-"z"])+(["a"-"z","0"-"9"])*>}void program(List<Function> funs): {  Tuple<AsmLabel, List<Instruction>> ret;} {  ret = lines(funs) <EOF>  {    if (ret.first != null) {      funs.add(new Function(ret.first, ret.second));    }  }}Tuple<AsmLabel, List<Instruction>> lines(List<Function> funs): {  Tuple<AsmLabel, List<Instruction>> ret =  	new Tuple<AsmLabel, List<Instruction>>();  AsmLabel currFun = null;  Instruction inst = null;  long addr;} {  (    addr = integer()    (         currFun = funhead(addr)        {          if (currFun != null) {            if (ret.first != null) {              funs.add(new Function(ret.first, ret.second));            }            ret.second = new ArrayList<Instruction>();            ret.first = currFun;          }        }      | inst = inst(addr) { ret.second.add(inst); }    )  )*  { return ret; }}AsmLabel funhead(long addr): {  String label;} {  (label = label() <NL>)  {  	if (label.startsWith(".L"))      return null;  	else      return new AsmLabel(label, addr);  }}Instruction inst(long addr): {  Operand op1, op2;  Opcode opcode;  ArrayList<Operand> operandList = new ArrayList<Operand>();  Instruction i;  boolean indirect = false;} {    	opcode = opcode()   	(  	  "*" op1 = operand() { operandList.add(op1); indirect = true; } |  	  (op1 = operand() { operandList.add(op1); } ("," op2 = operand() { operandList.add(op2); })*)?  	) <NL>    {    i = Instruction.createInstruction(addr, opcode, operandList.toArray(new Operand[0]), indirect);    return i;  }}Operand operand(): {  Operand ret;  } {  (ret = reg() | ret = mem() | ret = imm()) {    if (ret.isRegister() && ((Register)ret).id == Register.Id.EIZ)      ret = Immediate.getImmediate(0);     return ret;  }}Memory mem(): {	long disp = 0;	Register base = null, off = null;	long multi = 1;	} {(    (    "(" (        (base = reg() ("," off = reg() ("," multi = integer())?)?)       | ("," off = reg() ("," (multi = integer())?)?)    ) ")"  |  disp = integer()  	("(" (        (base = reg() ("," off = reg() ("," (multi = integer())?)?)?)      | ("," off = reg() ("," (multi = integer())?)?)    ) ")")? | base = sreg() ":" (disp = integer())? ("(" off = reg() ")")?  )) { return new Memory(disp, base, off, (int)multi); }}long integer(): { Token t;} { t = <INT> { return Long.decode(t.toString()); } }Immediate imm(): { Token t; } {  t = <IMM> { return Immediate.getImmediate(Long.parseLong(t.toString().substring(3), 16)); }}Register reg(): { Token t; Register reg; } {  t = <REG> {    reg = Register.getRegister(t.toString().substring(1));    return reg;  } }Register sreg(): { Token t; } { t = <SREG> { return Register.getRegister(t.toString().substring(1));} }String label(): {  Token t;  String l;} {  t = <LABEL>  { l = t.toString(); return l.substring(0, l.length() - 1); }}Opcode opcode(): {  Token t;} {   t = <OPCODE> { return new Opcode(t.toString()); }}